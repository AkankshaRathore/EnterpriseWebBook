:toc:
:toclevels: 4

== Sencha Touch

Sencha Touch framework is a little brother of Ext JS. They both have the same creator: http://www.sencha.com/[Sencha Inc], and they both are build on the same core classes. But Sencha Touch is created for developing mobile Web, while Ext JS is for desktop Web applications. The enterprise IT managers need to be aware of another important difference: Ext JS offers free licenses only for open source projects, but http://www.sencha.com/products/touch/license/[Sencha Touch licenses] are free for all.   

This chapter is structured similarly to the previous one on jQuery Mobile. The fundamental difference though is that if Chapter 12 has almost no JavaScript, this chapter will have almost no HTML. 

We'll try minimizing repeating the information you can find in http://www.sencha.com/learn/touch[Sencha Touch Learning Center] and extensive product documentation, which has multiple well written http://docs.sencha.com/touch/2.2.0/#!/guide[Guides] on multiple topics. The chapter will start with a brief overview of the features of Sencha Touch followed by the code review of yet another version of the Save Sick Child application. 
In this chapter we are going to use Sencha Touch 2.2, which is the latest version at the time of this writing. It supports iOS, Android, Blackberry, and recently have announced support of Window Phone 8. 

NOTE: If you haven't read Chapter 6 on Ext JS, please do it now. Both of these frameworks are built on the same foundation and we assume that you are familiar with such concepts as MVC architecture and things like `xType`, SASS and others explained in Chapter 6. Ext JS and Sencha Touch non-UI classes are not 100% compatible, but for the most part they are.

=== Sencha Touch Overview

Let's start with downloading Sencha Touch from http://www.sencha.com/products/touch/download/[http://www.sencha.com/products/touch/download]. To get the free commercial license just specify your email address, and you'll receive the link to download in the email. The Sencha Touch framework comes as a zip file, which you should unzip in the directory of your choice - later on the framework will be copied either into your project directory or in the document root of your Web server.  

But commercial license of Sencha Touch doesn't include charts (you'd need to get either Sencha Complete or Sencha Touch Bundle for the chart support). Because of this we'll be using the GPL version for the open source Save Sick Child project, but our users will see a little watermark as shown on the <<FIG13-1>> figure below. 

[[FIG13-1]]
.A GPL license watermark 
image::images/fig_13_01.png[]

After downloading Sencha Touch in the directory _/Library/touch-2.2.1_, but later on the code generation process will copy this framework in our application directory anyway.

==== Generating Hello World

If you haven't downloaded and installed the Sencha CMD tool, do it now as described in Chapter 6. We'll use Sencha CMD again, but this time to generate a mobile Hello World.  After opening a Terminal or Command Window enter the following command specifying the absolute path to your ExtJS SDK directory (we keep it in the /Library directory) and to the output folder, where the generated project should reside.

_sencha -sdk /Library/touch-2.2.1 generate app HelloWorld /Users/yfain11/hellotouch_

After the code generation was complete, you'll see the folder _hello_ of the structure shown on the figure <<FIG13-2>>. It follows the same MVC pattern that we've discussed in the Ext JS chapter.

[[FIG13-2]]
.CMD-generated project 
image::images/fig_13_02.png[image]

To test your newly generated application you'll need to make sure that the directory _hellotouch_ is deployed under a Web server (simple opening of index.html in the Web browser won't work). You can either install any Web server or just follow the instructions from section about XAMPP and Apache Web Server in Chapter 6. 

In this chapter we are going to use the internal Web server that comes with WebStorm IDE. It runs on the port 63342, and if your project's name is helloworld, just enter in your Web browser http://localhost:63342/helloworld to run it.

NOTE: To debug your code inside WebStorm IDE, select the menu Run | Edit Configurations, press the plus sign in the top left corner and in JavaScipt Debug | Remote panel enter the URL http://localhost:63342 followed by the name of your project(e.g. ssctouch) and name your new debug configuration. After that you'll be able to debug your code in your Chrome Web browser (it'll ask you to install the JetBrains IDE Support extension of the first run).



TIP: MAC OS X users can install a small application http://anvilformac.com/[Anvil] that can easily serve static content of any directory as a Web server with a URL that ends with .dev.

The Figure <<FIG13-3>> shows how the generated Hello World application will look in Chrome browser. It'll consist of two pages controlled by the buttons in the footer toolbar.

[[FIG13-3]]
.Running CMD-generated Hello World 
image::images/fig_13_03.png[image]

===== Microloader and Configurations

The main application entry is the Javascript file app.js. But if in Ext JS, this file was directly referenced in index.html, Sencha Touch applications generated by CMD tool use a separate microloader script, which starts with loading the file app.json that contains the names of the resources needed for your application including the app.js. The only script included in the generated index.html is this one:

[source, html]
----
<script id="microloader" type="text/javascript" 
       src="touch/microloader/development.js"></script>
----

This scripts uses one of the microloader scripts, which gets the objects to be loaded from the configuration file app.json. This file contains a JSON object with various attributes like `js`, `css`, `resources` and others. So if your application needs to load the scripts sencha-touch.js and app.js, they should be located in the `js` array. Here's what the `js` attribute of the app.json contains after the initial code generation by Sencha CMD:  

[source, javascript]
----
"js": [
    {
        "path": "touch/sencha-touch.js",
        "x-bootstrap": true
    },
    {
        "path": "app.js",
        "bundle": true,  
        "update": "delta"
    }
]
----

Eventually, if you'll need to load additional JavaScript code, CSS files or other resources add them to the appropriate attribute in the file app.json.

Introducing a separate configuration file and additional microloader script may seem like an unnecessary complication, but it's not. On the contrary, it gives you the flexibility of maintaining a clean separation between development, testing,  and production environments. You can find three different loader scripts in the folder _touch/microloader_: development.js, production.js, and testing.js.  Each of them can load different configuration file. 

If you open the production loader, you'll see that it uses application cache to save files locally on the device (see section Application Cache in Chapter 2 for a refresher) so the user can start the application even without having the Internet connection.

The production microloader of Sencha Touch offers a smarter solution for minimizing unnecessary loading of cached JavaScript and CSS files than HTML5 Application Cache. The standard HTML5 mechanism  doesn't know which resources has changed and reloads all cacheable resources. CMD-generated production builds for Sencha touch keep track of changes and create deltas, so the mobile device will download only those resources that has been actually changed. To create a production build open a Teminal or a command window, change to your application directory and run the following command: 

_sencha app build production_

See the section http://docs.sencha.com/touch/2.2.1/#!/guide/command_app["Deploying Your Application"] for more details on Sencha CMD builds. When we start building the Save Sick Child application, you'll see how to prompt the user that the application has been updated. Refer to the http://docs.sencha.com/cmd/3.1.2/#!/guide/command_app_touch[online documentation] on using Sencha CMD with Sencha Touch for details.

.Modularization and Code Distribution
************
Reducing the startup latency and implementing lazy loading of certain parts of the application are main reasons for modularizing Web applications. The other reason for modularization is an ability to redeploy certain portions of the code vs. the entire application if the code modifications are limited in scope. The ability of Sencha Touch to monitor modified pieces of code is great from the distribution perspective - just change the SomeFile.js on the server and it'll be automatically downloaded and saved on the user's mobile device.

What about the latency during the startup? Should we load the entire code base from the local storage (it's a lot faster that getting the code from remote servers) or still use loaders to bring up the portion of the code (a.k.a. modules) on as needed basis? There is no general answer to this question - every application is different.

If your application is not too large and the mobile device has enough memory, loading the entire code of the Web application from the local storage may lower the need for modularization. For larger applications consider the http://docs.sencha.com/touch/2.2.1/#!/guide/command_workspace[Workspaces] feature of Sencha CMD, which allows to create some common code to be shared by several scripts.
************

===== The Main View of Hello World

Similarly to Ext JS, the starting point of the Hello World application is app.js shown next and should be self explanatory. 

[source, javascript]
----
Ext.Loader.setPath({
    'Ext': 'touch/src',
    'HelloWorld': 'app'
});

Ext.application({
    name: 'HelloWorld',

    requires: [
        'Ext.MessageBox'
    ],

    views: [
        'Main'
    ],

    icon: {
        '57': 'resources/icons/Icon.png',
        '72': 'resources/icons/Icon~ipad.png',
        '114': 'resources/icons/Icon@2x.png',
        '144': 'resources/icons/Icon~ipad@2x.png'
    },

    isIconPrecomposed: true,

    startupImage: {
        '320x460': 'resources/startup/320x460.jpg',
        '640x920': 'resources/startup/640x920.png',
        '768x1004': 'resources/startup/768x1004.png',
        '748x1024': 'resources/startup/748x1024.png',
        '1536x2008': 'resources/startup/1536x2008.png',
        '1496x2048': 'resources/startup/1496x2048.png'
    },

    launch: function() {
        // Destroy the #appLoadingIndicator element
        Ext.fly('appLoadingIndicator').destroy();

        // Initialize the main view
        Ext.Viewport.add(Ext.create('HelloWorld.view.Main'));
    },

    onUpdated: function() {
        Ext.Msg.confirm(
            "Application Update",
            "This application has just successfully been updated to the latest version. Reload now?",
            function(buttonId) {
                if (buttonId === 'yes') {
                    window.location.reload();
                }
            }
        );
    }
});
----

The structure of the generated Main.js, which is a main view of this application is also straight forward. It extends the class `Ext.tab.Panel` so each page of the application is a tab. Figure <<FIG13-4>> is a snapshot of a collapsed version of the Main.js taken from WebStorm IDE, which will be our IDE of choice in this chapter. 

[[FIG13-4]]
.Collapsed version of Main.js
image::images/fig_13_04.png[image]

As you see from this figure the `items[]` array includes two objects: Welcome and Get Started - each of them is one tab (screen).


[source, html]
----
Ext.define('HelloWorld.view.Main', {
  extend: 'Ext.tab.Panel',
  xtype: 'main',
  requires: [
      'Ext.TitleBar',
      'Ext.Video'
  ],
  config: {
    tabBarPosition: 'bottom',          // <1>

    items: [
        {                              // <2>
            title: 'Welcome',
            iconCls: 'home',

            styleHtmlContent: true,
            scrollable: true,

            items: {
                docked: 'top',
                xtype: 'titlebar',
                title: 'Welcome to Sencha Touch 2'
            },

            html: [
                "You've just generated a new Sencha Touch 2 project. What you're looking at right now is the ",
                "contents of <a target='_blank' href=\"app/view/Main.js\">app/view/Main.js</a> - edit that file ",
                "and refresh to change what's rendered here."
            ].join("")
        },
        {                               // <3>
            title: 'Get Started',
            iconCls: 'action',

            items: [
                {
                    docked: 'top',
                    xtype: 'titlebar',
                    title: 'Getting Started'
                },
                {
                    xtype: 'video',
                    url: 'http://av.vimeo.com/64284/137/87347327.mp4?token=1330978144_f9b698fea38cd408d52a2393240c896c',
                    posterUrl: 'http://b.vimeocdn.com/ts/261/062/261062119_640.jpg'
                }
            ]
        }
      ]
  }
});
----

<1> The tab bar has to be located at the bottom of the screen.

<2> The first tab is a Welcome screen.

<3> The second tab is a Getting Started screen. It has `xtype: video`, which means it's ready for playing video located at the specified `url`.   

This application has no controllers, models or stores. But it does include the default theme from SASS stylesheet resources/sass/app.scss, which was compiled by Sencha CMD generation process into resources/css/app.css. 

==== UI Components and Events

Sencha Touch has a number of well designed UI components for mobile devices, which include lists, forms, toolbars and buttons, charts, audio, video, carousel and more.  The quickest way to get familiar with events and UI components is by browsing the http://dev.sencha.com/deploy/touch/examples/production/kitchensink/[Kitchen Sink] Web site, where you can find the examples of how UI components look and 

==== Implementing Navigation

While designing the navigation for the mobile device you'll be creating a set of views that will replace each other on the user's device.

===== Touches and Gestures

The Scroller class

==== Layouts 

UI components have to be laid out on the user's screen. 


=== Save Sick Child With Sencha Touch

The Sencha Touch version of the Save Sick Child application will be based on the prototype from Chapter 12, section "Prototyping Mobile Version" with minor changes. This time the home page of the application will be a slightly different version of the About page shown on <<FIG13-11>>. 

In Chapter 6 we started using http://www.jetbrains.com/webstorm/[WebStorm IDE] from JetBrain, and this is going to be our IDE of choice.

IMPORTANT: The materials presented in this chapter were tested only with the current version of Sencha Touch framework, which at the time of this writing was 2.2.1.

[[FIG13-11]]
.The Starting/About page
image::images/fig_13_11.png[]

Below is the code of the app.js in the Save Sick Child project (we've just removed the default startup images and icons for brevity). For the most part is has the same structure as Ext JS applications.

[source, javascript]
----
Ext.application({
    name: 'SSC',

    requires: [
        'Ext.MessageBox'
    ],

    views: [
        'About',
        'CampaignsMap',
        'DonateForm',
        'DonorsChart',
        'LoginForm',
        'LoginToolbar',
        'Main',
        'Media',
        'Share',
        'ShareTile'
    ],

    stores: [
        'Campaigns',
        'Countries',
        'Donors',
        'States',
        'Videos'
    ],

    controllers: [
        'Login'
    ],

    launch: function() {
        // Destroy the #appLoadingIndicator element
        Ext.fly('appLoadingIndicator').destroy();

        // Initialize the main view
        Ext.Viewport.add(Ext.create('SSC.view.Main'));
    },

    onUpdated: function() {
        Ext.Msg.confirm(
            "Application Update",
            "This application has just successfully been updated to the latest version. Reload now?",
            function(buttonId) {
                if (buttonId === 'yes') {
                    window.location.reload();
                }
            }
        );
    }
});

----

All the store listed in app.js will be automatically instantiated. The views that require data from the store will either mention the store name like `store: 'Videos'` or will explicitly use the class `StoreMgr`, for example `Ext.StoreMgr.get('Campaigns');`. In this version of the application we have only one controller `Login` that doesn't use any stores, but the mechanism of pointing controllers to the appropriate store instances is the same as for views. This version of the Save Sick Child application doesn't use explicitly defined models - all the data are hard-coded in the stores in the `data` attributes.

You'll see the code of the views a bit later, but we wanted to draw your attention to the `onUpdated()` event handler. In the section "Microloader and Configurations" we've mentioned that production builds of Sencha Touch applications are watching the locally cached JavaScript and CSS files listed in the JS and CSS sections of the configuration file app.json and compare them with their peers on the server. They also watch all the files listed in the `appCache` section of app.json. If any of these files changes, the `onUpdated` event handler is invoked, if any. For illustration purposes we decided to intercept this event and Figure <<13-12>> shows how the update prompt can look like on iPhone 5.

[[FIG13-12]]
.The code on the server has changed
image::images/fig_13_12.png[]

At this point the user can either select working with the previous version of the application or reload the new one. 

The index.html file of our application beside the microloader script includes one more script that supports Google Maps API.

[source, html]
----
<script type="text/javascript" src="http://maps.google.com/maps/api/js?sensor=true"></script>
---- 

TIP: If you want your program documentation look as good as Sencha's use https://github.com/senchalabs/jsduck[JSDuck tool].

The code of the UI landing page of this application is located in the _views_ folder in the file Main.js. First, take a look at the screenshot from WebStorm IDE on figure <<FIG13-13>> that there are only two objects on the top level: the container and a login form.  

[[FIG13-13]]
.The Main.js in a collapsed form
image::images/fig_13_13.png[] 

The `card` layout means that the user will see either the content of that container or the login form - one at a time. Let's open up the container. It has an array of children, which are our application pages. The figure <<FIG13-14>> show who are the children.

[[FIG13-14]]
.The container's children in a collapsed form
image::images/fig_13_14.png[] 

The entire code of the Main.js is shown next.

[source, javascript]
----
Ext.define('SSC.view.Main', {
   extend: 'Ext.Container',
   xtype: 'mainview',             // <1>
   requires: [
       'Ext.tab.Panel',
       'Ext.Map',
       'Ext.Img'
   ],

   config: {
     layout: 'card',

     items: [
       { xtype: 'container',
         layout: 'fit',

         showAnimation: {
             type: 'slide',
             direction: 'down',
             duration: 200
         },

         items: [
           { xtype: 'tabpanel',
             tabBarPosition: 'bottom',

             items: [
               {  title: 'About',
                  iconCls: 'info',   // <2>  
                  layout: 'fit',     // <3>
                  items: [
                    {xtype: 'aboutview'}
                  ]
               },
               {  title: 'Donate',
                  iconCls: 'love',
                  layout: 'fit',
                  items: [
                    { xtype: 'logintoolbar',
                      title: 'Donate'
                    },
                    {xtype: 'donateform'}
                  ]
               },
               {  title: 'Stats',
                  iconCls: 'pie',
                  layout: 'fit',
                  items: [
                    { xtype: 'logintoolbar',
                      title: 'Stats'
                    },
                    { xtype: 'donorschart'}
                  ]
               },
               {  title: 'Events',
                  iconCls: 'pin',
                  layout: 'fit',
                  items: [
                    { xtype: 'logintoolbar',
                      title: 'Events'
                    },
                    { xtype: 'campaignsmap'}
                  ]
               },
               {  title: 'Media',
                  iconCls: 'media',
                  layout: 'fit',
                  items: [
                    { xtype: 'mediaview'}
                  ]
               },
               {  title: 'Share',
                  iconCls: 'share',
                  layout: 'fit',
                  items: [
                    { xtype: 'logintoolbar',
                      title: 'Share'
                    },
                    {xtype: 'shareview'}
                  ]
               }
             ]
           }
         ]
       },
       { xtype: 'loginform',

         showAnimation: {
             type: 'slide',
             direction: 'up',
             duration: 200
         }
       }
     ]
   } 
});
----

<1> We've assigned the `xtype: 'mainview` to the main view so to  allow the Login controller refer to it (see its code below). 

<2> Each of the tabs has a corresponding button on the toolbar. It shows the text from the `title` attribute and the icon from the `iconCls`. 

<3> Each of the view has http://docs.sencha.com/extjs/4.1.3/#!/api/Ext.layout.container.Fit[`fit` layout], which forces the content to expand to fill the layout's container.

Now let's review the code of the Login page controller. It has no login logic, and implements the UI only. The name of this file is Login.js and it's located in the folder _controller_. 

[source, javascript]
----
Ext.define('SSC.controller.Login', {
    extend: 'Ext.app.Controller',

    config: {
        refs: {
            mainView: 'mainview',           // <1>
            loginButton: 'button[action=login]',
            loginForm: 'loginform',         // <2> 
            cancelButton: 'loginform button[action=cancel]'
        },

        control: {                         // <3>
            loginButton: {
                tap: 'showLoginView'
            },
            cancelButton: {
                tap: 'cancelLogin'
            }
        }
    },

    showLoginView: function () {
        this.getMainView().setActiveItem(1);  // <4>
    },

    cancelLogin: function () {
        this.getMainView().setActiveItem(0);  //  <5> 
    }

});
----

<1> Including the `mainView: 'mainview'` in the `refs` attribute forces Sencha Touch to generate the getter providing access to the main view.

<2> This controller uses components from the LoginForm view (it's code comes next).

<3>  Defining the event handlers for tap events for the buttons Login and Cancel from the LoginForm view.

<4> The main view has two children (see <<FIG13-13>>). When the use clicks on the Login button, show the second child: `setActiveItem(1)`.
  
<5> When the use clicks on the Cancel button, show the main container - the first child of the main view: `setActiveItem(0)`.

The figure <<FIG13-15>> is a snapshot of Login view taken from iPhone 5. 

[[FIG13-15]]
.The Login View
image::images/fig_13_15.png[] 

This is how the code of the Login view view looks like - it's self explanatory. The `ui: 'decline'` is the http://try.sencha.com/touch/2.2.0/demos/Ext.Button.ui/[`Ext.Button` style] that causes the Cancel button have a red background.

[source, javascript]
----
Ext.define('SSC.view.LoginForm', {
  extend: 'Ext.form.Panel',
  xtype: 'loginform',
  requires: [
      'Ext.field.Password'
  ],

  config: {
    items: [
        {   xtype: 'toolbar',
            title: 'Login',

            items: [
                {   xtype: 'button',
                    text: 'Cancel',
                    ui: 'decline',
                    action: 'cancel'
                }
            ]
        },
        {  xtype: 'fieldset',
            title: 'Please enter your credentials',

            defaults: {
                labelWidth: '35%'
            },

            items: [
                {   xtype: 'textfield',
                    label: 'Username'
                },
                {   xtype: 'passwordfield',
                    label: 'Password'
                }
            ]
        },
        {  xtype: 'button',
            text: 'Login',
            ui: 'confirm',
            margin: '0 10'
        }
    ]
  }
});
----

TIP: If you'll add the Save Sick Child application as an icon to the home screen on iOS devices, the browser's address bar will not be displayed.

=== Summary 

In chapters 12 and 13 you've learned about two different ways of developing a mobile application. So what's better jQuery Mobile or Sencha Touch? There is no answer to this question, and you will have to make a decision on your own. But here's a quick summary of pros and cons for each library or framework.

* If you are afraid of being locked up with any one vendor, go with jQuery Mobile.

* If you need your application to work on most of the mobile platforms the jQuery Mobile is for you.

* If you prefer declarative UI and hate debugging JavaScript select jQuery Mobile.

* If you like to have a rich library of pre-created UI components go with Sencha Touch.

* If your application needs smooth animation, go with Sencha Touch - it does automatic throttling based on the actual frames per seconds supported on the device.

* If splitting the application code into cleanly defined architectural layers (model-view-controller-service) is important, go with Sencha Touch.

* If you believe that using code generators add value to your project, go with Sencha.

* If you want to be able customize and extend components to fit your application's needs perfectly, use Sencha Touch. Yes, you'll be writing JavaScript, but it still may be simpler than trying to figure out the enhancements done to HTML component by jQuery Mobile under the hood. 

* If you want to minimize the efforts required to package your application as a native one, use Sencha Touch.

* If you won't sleep well at night unless you development project is covered by commercial vendor support, use Sencha Touch.

While considering support options do not just assume that paid support translates into better quality. This is not to say that Sencha won't offer you quality support, but in many cases having a large community of developers will lead to a faster solution to a problem that dealing with one assigned support engineer. Having said this, we'd like you to know that http://www.sencha.com/forum/[Sencha forum] has about half a million registered users who are actively discussing problems and offering solutions to each other.


Even if you are a developer's manager, you don't have to make the framework choice on your own. Bring your team into a conference room, order pizza, and listen to what _your team members_ have to say about these two or any other frameworks being considered. We offered you the information about two of many frameworks, but the final call is yours.



